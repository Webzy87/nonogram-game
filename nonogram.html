<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Nonogram (Co-op)</title>
<style>
  :root{
    --bg:#f6f8ff; --card:#fff; --ink:#152047; --muted:#4a5a8a; --line:#d7def6;
    --accent:#2b6bff; --rose:#7b3cff; --x:#d9415a;
    --cell:#fff; --cellEdge:#cfd8ff;
    --shadow:0 12px 30px rgba(12,24,80,.12);
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{
    background:radial-gradient(1100px 700px at 20% 10%, #e7efff 0%, var(--bg) 60%);
    color:var(--ink);display:flex;justify-content:center;align-items:center;padding:18px;
  }
  .wrap{max-width:1200px;width:100%;display:grid;gap:16px;grid-template-columns:400px 1fr;}
  @media (max-width:900px){.wrap{grid-template-columns:1fr;}}
  .panel,.board{background:var(--card);border:1px solid var(--line);box-shadow:var(--shadow);border-radius:18px;overflow:hidden;}
  .panel{padding:16px;}
  .board{position:relative;padding:14px;display:flex;justify-content:center;align-items:flex-start;min-height:520px;}
  h1{font-size:18px;margin:0 0 8px}
  .sub{color:var(--muted);font-size:13px;line-height:1.35;margin-bottom:12px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:10px 0}
  button,select{
    border-radius:12px;padding:10px 12px;font-weight:900;cursor:pointer;
    border:1px solid var(--line);background:#f7f9ff;color:var(--ink);
  }
  button:hover{background:#eef3ff}
  button.danger{background:rgba(217,65,90,.10);border-color:rgba(217,65,90,.25)}
  button.secondary{background:rgba(21,32,71,.06);border-color:rgba(21,32,71,.12)}
  button.primary{background:rgba(43,107,255,.14);border-color:rgba(43,107,255,.35)}
  label{font-size:12px;color:var(--muted);font-weight:800}
  .stat{font-size:13px;color:var(--muted);font-weight:800}
  .turnTag{font-weight:950;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:#fff;}
  .you{color:var(--accent)} .rose{color:var(--rose)}

  .toolBtn{border-radius:14px;padding:10px 12px;border:1px solid var(--line);background:#f7f9ff;font-weight:950;user-select:none}
  .toolBtn.active{border-color:rgba(43,107,255,.45);background:rgba(43,107,255,.12)}
  .toolIcon{display:inline-flex;width:26px;height:26px;border-radius:10px;align-items:center;justify-content:center;margin-right:8px;font-weight:1000}
  .icoFill{background:rgba(43,107,255,.18);color:var(--accent)}
  .icoX{background:rgba(217,65,90,.14);color:var(--x)}
  .icoErase{background:rgba(21,32,71,.06);color:var(--ink)}

  .toast{
    margin-top:10px;padding:10px 12px;border-radius:12px;border:1px solid var(--line);
    background:#f7f9ff;color:var(--muted);font-size:13px;min-height:18px;font-weight:850
  }

  .game{display:grid;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;gap:10px;align-items:start;}
  .corner{
    width:86px;height:86px;border-radius:14px;background:#f0f4ff;border:1px solid var(--line);
    display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px;font-weight:950;
    user-select:none;
  }
  .colClues{display:grid;align-items:end;}
  .rowClues{display:grid;align-items:start;}

  .colClue,.rowClue{
    box-sizing:border-box;background:#f7f9ff;border:1px solid var(--line);border-radius:12px;
    color:var(--muted);font-size:12px;font-weight:950;overflow:hidden;
    transition:opacity .15s ease, filter .15s ease, background .15s ease;
  }
  .colClue{
    height:86px;
    display:flex;
    flex-direction:column;
    justify-content:flex-end;
    align-items:center;
    text-align:center;
    line-height:1.05;
    padding:6px 4px;
  }
  .rowClue{display:flex;align-items:center;justify-content:flex-end;gap:6px;padding:0 10px;}

  .clueDone{
    opacity:.45;
    filter:saturate(.6);
    background:rgba(21,32,71,.03);
  }

  .grid{display:grid;background:var(--cellEdge);border-radius:14px;box-sizing:border-box;}
  .cell{
    background:var(--cell);border-radius:12px;display:flex;align-items:center;justify-content:center;
    font-weight:950;font-size:18px;cursor:pointer;border:1px solid rgba(207,216,255,.65);box-sizing:border-box;
    transition: background .12s ease, outline .12s ease, transform .06s ease;
  }
  .cell:active{transform:scale(.98)}
  .cell.fill{background:linear-gradient(180deg, rgba(43,107,255,.95), rgba(43,107,255,.75));border-color:rgba(43,107,255,.25)}
  .cell.x::after{content:"‚úï";color:rgba(217,65,90,.95)}
  .cell.wrong{outline:3px solid rgba(217,65,90,.45);outline-offset:-2px}
  .cell.lastMove{outline:3px solid rgba(43,107,255,.28);outline-offset:-2px}

  /* highlight row/col like real apps */
  .cell.hl{background:rgba(43,107,255,.08)}
  .cell.hl.fill{background:linear-gradient(180deg, rgba(43,107,255,.95), rgba(43,107,255,.75))}

  /* WIN OVERLAY */
  .winOverlay{
    position:absolute; inset:0;
    display:none;
    align-items:center; justify-content:center;
    background:rgba(246,248,255,.78);
    backdrop-filter: blur(6px);
    z-index:5;
  }
  .winCard{
    width:min(520px, 92%);
    background:#fff;
    border:1px solid var(--line);
    border-radius:18px;
    box-shadow: var(--shadow);
    padding:16px;
  }
  .winTitle{font-size:18px;font-weight:1000;margin:0 0 6px}
  .winSub{color:var(--muted);margin:0 0 12px;font-weight:800;font-size:13px;line-height:1.35}
  .winBtns{display:flex;gap:10px;flex-wrap:wrap}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Nonogram ‚Äî Co-op (You + Rose)</h1>
    <div class="sub">
      Pick a tool then tap the grid. Win = you get a big ‚ÄúNEXT PUZZLE‚Äù button like you deserve.
    </div>

    <div class="row">
      <div><label>Grid size</label><br/>
        <select id="size">
          <option value="5">5√ó5</option>
          <option value="10" selected>10√ó10</option>
          <option value="15">15√ó15</option>
        </select>
      </div>
      <div><label>Fill density</label><br/>
        <select id="density">
          <option value="0.33">Light</option>
          <option value="0.45" selected>Medium</option>
          <option value="0.55">Heavy</option>
        </select>
      </div>
      <div><label>Mistakes</label><br/>
        <select id="mistakes">
          <option value="show" selected>Show mistakes</option>
          <option value="off">Off</option>
          <option value="block">Block wrong moves</option>
        </select>
      </div>
    </div>

    <div class="row" style="gap:14px;">
      <label style="display:flex;align-items:center;gap:8px;">
        <input type="checkbox" id="vsRose" checked />
        Vs Rose (auto moves)
      </label>

      <div>
        <label>Rose brain</label><br/>
        <select id="roseBrain">
          <option value="fair" selected>Fair (no peeking)</option>
          <option value="peek">Peek (perfect)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div class="toolBtn active" id="toolFill"><span class="toolIcon icoFill">O</span>Fill</div>
      <div class="toolBtn" id="toolX"><span class="toolIcon icoX">X</span>Mark X</div>
      <div class="toolBtn" id="toolErase"><span class="toolIcon icoErase">‚å´</span>Erase</div>
    </div>

    <div class="row">
      <button id="newBtn" class="primary">New puzzle</button>
      <button id="checkBtn" class="secondary">Check win</button>
      <button id="revealBtn" class="danger">Reveal</button>
    </div>

    <div class="row">
      <div class="stat">Moves: <b id="moves">0</b></div>
      <div class="stat">Time: <b id="time">00:00</b></div>
      <div class="stat">Turn: <span class="turnTag" id="turnTag"><span class="you">You</span></span></div>
    </div>

    <div class="toast" id="toast">Go on then üòô</div>
  </div>

  <div class="board">
    <div class="winOverlay" id="winOverlay">
      <div class="winCard">
        <div class="winTitle">‚úÖ Solved.</div>
        <p class="winSub">That was clean. Want the next one? (You can also keep staring at your masterpiece.)</p>
        <div class="winBtns">
          <button id="nextBtn" class="primary">Next puzzle</button>
          <button id="stayBtn" class="secondary">Keep looking</button>
        </div>
      </div>
    </div>

    <div class="game" id="game"></div>
  </div>
</div>

<script>
(() => {
  const elGame = document.getElementById("game");
  const elMoves = document.getElementById("moves");
  const elTime  = document.getElementById("time");
  const elToast = document.getElementById("toast");
  const elTurn  = document.getElementById("turnTag");

  const sizeSel = document.getElementById("size");
  const denSel  = document.getElementById("density");
  const misSel  = document.getElementById("mistakes");
  const vsRose  = document.getElementById("vsRose");
  const roseBrain = document.getElementById("roseBrain");

  const toolFill = document.getElementById("toolFill");
  const toolX    = document.getElementById("toolX");
  const toolErase= document.getElementById("toolErase");

  const newBtn   = document.getElementById("newBtn");
  const checkBtn = document.getElementById("checkBtn");
  const revealBtn= document.getElementById("revealBtn");

  const winOverlay = document.getElementById("winOverlay");
  const nextBtn = document.getElementById("nextBtn");
  const stayBtn = document.getElementById("stayBtn");

  const CELL=42, GAP=2;

  let N=10, solution=[], player=[], rowClues=[], colClues=[];
  let moves=0, turn=1, currentTool="fill", lastMove=null;
  let timer=null, startTs=0;
  let lockedSolved=false;

  // cached clue elements for dimming
  let rowClueEls = [];
  let colClueEls = [];
  let cellEls = []; // flat list for highlight updates

  const toast = s => elToast.textContent=s;

  function setTool(t){
    currentTool=t;
    toolFill.classList.toggle("active", t==="fill");
    toolX.classList.toggle("active", t==="x");
    toolErase.classList.toggle("active", t==="erase");
  }
  toolFill.onclick=()=>setTool("fill");
  toolX.onclick=()=>setTool("x");
  toolErase.onclick=()=>setTool("erase");

  function pad2(n){return String(n).padStart(2,"0");}
  function resetTimer(){
    if(timer) clearInterval(timer);
    startTs=Date.now();
    timer=setInterval(()=>{
      const s=Math.floor((Date.now()-startTs)/1000);
      elTime.textContent=`${pad2(Math.floor(s/60))}:${pad2(s%60)}`;
    },500);
  }

  function rnd(min,max){return Math.floor(Math.random()*(max-min+1))+min;}

  function makeSolution(n,d){
    const g=Array.from({length:n},()=>Array(n).fill(false));
    const seeds=Math.max(1,Math.floor(n/4));
    const targets=Math.floor(n*n*d);
    const frontier=[];
    for(let i=0;i<seeds;i++){
      const r=rnd(0,n-1), c=rnd(0,n-1);
      g[r][c]=true; frontier.push([r,c]);
    }
    let filled=frontier.length;
    const dirs=[[1,0],[-1,0],[0,1],[0,-1]];
    while(filled<targets && frontier.length){
      const idx=rnd(0,frontier.length-1);
      const [r,c]=frontier[idx];
      const [dr,dc]=dirs[rnd(0,3)];
      const rr=r+dr, cc=c+dc;
      if(rr>=0&&rr<n&&cc>=0&&cc<n){
        if(!g[rr][cc]){ g[rr][cc]=true; frontier.push([rr,cc]); filled++; }
      } else frontier.splice(idx,1);
    }
    return g;
  }

  function cluesFromLine(line){
    const out=[]; let run=0;
    for(const v of line){
      if(v) run++;
      else if(run){ out.push(run); run=0; }
    }
    if(run) out.push(run);
    return out.length ? out : [0];
  }

  function computeClues(sol){
    const rows=[], cols=[];
    for(let r=0;r<N;r++) rows.push(cluesFromLine(sol[r]));
    for(let c=0;c<N;c++){
      const col=[]; for(let r=0;r<N;r++) col.push(sol[r][c]);
      cols.push(cluesFromLine(col));
    }
    return {rows, cols};
  }

  function updateTurn(){
    elTurn.innerHTML = (turn===1) ? `<span class="you">You</span>` : `<span class="rose">Rose</span>`;
  }

  function showWinOverlay(){
    winOverlay.style.display="flex";
  }
  function hideWinOverlay(){
    winOverlay.style.display="none";
  }

  nextBtn.onclick=()=>{ hideWinOverlay(); newPuzzle(); };
  stayBtn.onclick=()=>hideWinOverlay();

  function buildUI(){
    elGame.innerHTML="";
    rowClueEls = [];
    colClueEls = [];
    cellEls = [];

    const clueW = N*CELL + (N-1)*GAP;
    const gridW = N*CELL + (N-1)*GAP + 2*GAP;

    const corner=document.createElement("div");
    corner.className="corner";
    corner.innerHTML=`<div>${N}√ó${N}<br/><span style="color:var(--muted)">Co-op</span></div>`;

    const colWrap=document.createElement("div");
    colWrap.className="colClues";
    colWrap.style.gridTemplateColumns=`repeat(${N}, ${CELL}px)`;
    colWrap.style.gap=`${GAP}px`;
    colWrap.style.width=`${clueW}px`;

    for(let c=0;c<N;c++){
      const d=document.createElement("div");
      d.className="colClue";
      d.style.width=`${CELL}px`;
      d.innerHTML = colClues[c].map(x=>`<div>${x}</div>`).join("");
      colWrap.appendChild(d);
      colClueEls.push(d);
    }

    const rowWrap=document.createElement("div");
    rowWrap.className="rowClues";
    rowWrap.style.gridTemplateRows=`repeat(${N}, ${CELL}px)`;
    rowWrap.style.gap=`${GAP}px`;

    for(let r=0;r<N;r++){
      const d=document.createElement("div");
      d.className="rowClue";
      d.style.height=`${CELL}px`;
      d.innerHTML = rowClues[r].map(x=>`<span>${x}</span>`).join("");
      rowWrap.appendChild(d);
      rowClueEls.push(d);
    }

    const grid=document.createElement("div");
    grid.className="grid";
    grid.style.gridTemplateColumns=`repeat(${N}, ${CELL}px)`;
    grid.style.gridTemplateRows=`repeat(${N}, ${CELL}px)`;
    grid.style.gap=`${GAP}px`;
    grid.style.padding=`${GAP}px`;
    grid.style.width=`${gridW}px`;

    for(let r=0;r<N;r++){
      for(let c=0;c<N;c++){
        const cell=document.createElement("div");
        cell.className="cell";
        cell.style.width=`${CELL}px`;
        cell.style.height=`${CELL}px`;
        cell.dataset.r=r; cell.dataset.c=c;

        const onFocus = () => setHighlight(r,c);
        cell.addEventListener("mouseenter", onFocus);
        cell.addEventListener("touchstart", onFocus, {passive:true});

        cell.onclick=()=>{
          if(lockedSolved) return; // after solved, you can still view but not edit
          const action = (currentTool==="fill")?1:(currentTool==="x")?2:0;
          doMove(r,c,action,cell,false);
        };

        grid.appendChild(cell);
        cellEls.push(cell);
      }
    }

    // clear highlight when leaving grid area
    grid.addEventListener("mouseleave", clearHighlight);

    elGame.appendChild(corner);
    elGame.appendChild(colWrap);
    elGame.appendChild(rowWrap);
    elGame.appendChild(grid);
  }

  function setHighlight(rr,cc){
    for(const cell of cellEls){
      const r=+cell.dataset.r, c=+cell.dataset.c;
      cell.classList.toggle("hl", r===rr || c===cc);
    }
  }
  function clearHighlight(){
    for(const cell of cellEls) cell.classList.remove("hl");
  }

  function renderCell(cell,r,c){
    cell.classList.toggle("fill", player[r][c]===1);
    cell.classList.toggle("x", player[r][c]===2);

    cell.classList.remove("wrong");
    if(misSel.value !== "off"){
      const wrongFill = (player[r][c]===1 && !solution[r][c]);
      const wrongX    = (player[r][c]===2 &&  solution[r][c]);
      if(wrongFill || wrongX) cell.classList.add("wrong");
    }
  }

  function renderAll(){
    for(const cell of cellEls){
      const r=+cell.dataset.r, c=+cell.dataset.c;
      renderCell(cell,r,c);
    }
    updateClueDimming();
  }

  function isWrong(action,r,c){
    if(action===1) return !solution[r][c];
    if(action===2) return  solution[r][c];
    return false;
  }

  function isWin(){
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(solution[r][c] !== (player[r][c]===1)) return false;
    }
    return true;
  }

  function setLast(cell){
    if(lastMove) lastMove.classList.remove("lastMove");
    lastMove=cell;
    if(lastMove) lastMove.classList.add("lastMove");
  }

  function lineCluesFromPlayerRow(r){
    const arr = [];
    for(let c=0;c<N;c++) arr.push(player[r][c]===1);
    return cluesFromLine(arr);
  }
  function lineCluesFromPlayerCol(c){
    const arr = [];
    for(let r=0;r<N;r++) arr.push(player[r][c]===1);
    return cluesFromLine(arr);
  }
  function sameClues(a,b){
    if(a.length!==b.length) return false;
    for(let i=0;i<a.length;i++) if(a[i]!==b[i]) return false;
    return true;
  }
  function updateClueDimming(){
    for(let r=0;r<N;r++){
      const ok = sameClues(lineCluesFromPlayerRow(r), rowClues[r]);
      rowClueEls[r].classList.toggle("clueDone", ok);
    }
    for(let c=0;c<N;c++){
      const ok = sameClues(lineCluesFromPlayerCol(c), colClues[c]);
      colClueEls[c].classList.toggle("clueDone", ok);
    }
  }

  function doMove(r,c,action,cell,byAI){
    if(vsRose.checked && turn===2 && !byAI) return;

    if(misSel.value==="block" && action!==0 && isWrong(action,r,c)){
      toast(turn===1 ? "Nope. Wrong move üòà" : "I caught myself. Almost flopped üòá");
      return;
    }

    if(action===0) player[r][c]=0;
    else if(action===1) player[r][c]=(player[r][c]===1)?0:1;
    else if(action===2) player[r][c]=(player[r][c]===2)?0:2;

    moves++; elMoves.textContent=moves;
    renderCell(cell,r,c);
    setLast(cell);
    updateClueDimming();

    if(isWin()){
      lockedSolved = true;
      toast("‚úÖ Solved. Teamwork makes the pixels purr.");
      showWinOverlay();
      return;
    }

    turn = (turn===1)?2:1;
    updateTurn();

    if(vsRose.checked && turn===2){
      setTimeout(roseMove, 240);
    }
  }

  // ---------- ROSE AI ----------
  // "peek" uses solution to be perfect.
  // "fair" uses simple nonogram-safe logic (no peeking). If no forced moves, she marks a safe X where clue is 0, otherwise picks a random unknown as X (conservative).
  function roseMove(){
    if(lockedSolved) return;

    toast("My turn. Don‚Äôt blink.");

    if(roseBrain.value === "peek"){
      // perfect: pick an empty cell and set correct mark
      const empties=[];
      for(let r=0;r<N;r++) for(let c=0;c<N;c++){
        if(player[r][c]===0) empties.push([r,c]);
      }
      if(!empties.length){ turn=1; updateTurn(); return; }
      const [r,c]=empties[rnd(0,empties.length-1)];
      const shouldFill=solution[r][c];
      const action = shouldFill ? 1 : 2;
      const cell = cellEls[r*N + c];
      setTimeout(()=>doMove(r,c,action,cell,true), 140);
      return;
    }

    // FAIR logic (no peeking)
    // Forced moves:
    // 1) clue [0] => everything is X
    // 2) if sum(clues)+gaps == N => fill all forced positions
    // 3) if a line already matches clues => mark remaining empties as X
    const forced = findForcedMove();
    if(forced){
      const {r,c,action} = forced;
      const cell = cellEls[r*N + c];
      setTimeout(()=>doMove(r,c,action,cell,true), 140);
      return;
    }

    // If nothing forced: conservative guess = place X on a random unknown
    const unknown=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(player[r][c]===0) unknown.push([r,c]);
    }
    if(!unknown.length){ turn=1; updateTurn(); return; }
    const [r,c]=unknown[rnd(0,unknown.length-1)];
    const cell = cellEls[r*N + c];
    setTimeout(()=>doMove(r,c,2,cell,true), 140);
  }

  function findForcedMove(){
    // helper: find first empty in a list of coords
    const firstEmpty = (coords) => {
      for(const [r,c] of coords) if(player[r][c]===0) return [r,c];
      return null;
    };

    // 1) rows with clue [0] => mark all X
    for(let r=0;r<N;r++){
      if(rowClues[r].length===1 && rowClues[r][0]===0){
        const coords = Array.from({length:N}, (_,c)=>[r,c]);
        const p = firstEmpty(coords);
        if(p) return {r:p[0], c:p[1], action:2};
      }
    }
    // 1b) cols with clue [0]
    for(let c=0;c<N;c++){
      if(colClues[c].length===1 && colClues[c][0]===0){
        const coords = Array.from({length:N}, (_,r)=>[r,c]);
        const p = firstEmpty(coords);
        if(p) return {r:p[0], c:p[1], action:2};
      }
    }

    // 2) packed lines: sum + (k-1) == N -> fill all forced
    function packedFillCoords(clues){
      if(clues.length===1 && clues[0]===0) return null;
      const sum = clues.reduce((a,b)=>a+b,0);
      const gaps = clues.length-1;
      if(sum + gaps !== N) return null;
      const coords = [];
      let idx=0;
      for(let i=0;i<clues.length;i++){
        for(let j=0;j<clues[i];j++) coords.push(idx++);
        if(i<clues.length-1) idx++; // gap
      }
      return coords; // indices to fill
    }

    for(let r=0;r<N;r++){
      const idxs = packedFillCoords(rowClues[r]);
      if(idxs){
        for(const c of idxs){
          if(player[r][c]===0) return {r, c, action:1};
        }
      }
    }
    for(let c=0;c<N;c++){
      const idxs = packedFillCoords(colClues[c]);
      if(idxs){
        for(const r of idxs){
          if(player[r][c]===0) return {r, c, action:1};
        }
      }
    }

    // 3) if line matches clues exactly, mark remaining empties as X
    for(let r=0;r<N;r++){
      if(sameClues(lineCluesFromPlayerRow(r), rowClues[r])){
        for(let c=0;c<N;c++){
          if(player[r][c]===0) return {r,c,action:2};
        }
      }
    }
    for(let c=0;c<N;c++){
      if(sameClues(lineCluesFromPlayerCol(c), colClues[c])){
        for(let r=0;r<N;r++){
          if(player[r][c]===0) return {r,c,action:2};
        }
      }
    }

    return null;
  }

  function reveal(){
    for(const cell of cellEls){
      const r=+cell.dataset.r, c=+cell.dataset.c;
      cell.style.outline = solution[r][c] ? "3px solid rgba(43,107,255,.28)" : "3px solid rgba(217,65,90,.20)";
      cell.style.outlineOffset="-2px";
    }
    toast("Reveal on. (Blue = filled, Pink = empty)");
  }

  function newPuzzle(){
    lockedSolved = false;
    hideWinOverlay();

    N=+sizeSel.value;
    const density=+denSel.value;

    solution=makeSolution(N,density);
    const clues=computeClues(solution);
    rowClues=clues.rows;
    colClues=clues.cols;

    player=Array.from({length:N},()=>Array(N).fill(0));
    moves=0; elMoves.textContent=moves;
    turn=1; updateTurn();
    lastMove=null;

    buildUI();
    renderAll();
    resetTimer();
    toast("New puzzle loaded. You first üòô");
  }

  newBtn.onclick=newPuzzle;
  checkBtn.onclick=()=>toast(isWin() ? "‚úÖ Yep. Solved." : "Not solved yet. Keep going.");
  revealBtn.onclick=reveal;

  // start
  newPuzzle();
})();
</script>
</body>
</html>
